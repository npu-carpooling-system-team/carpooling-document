<div align="center">
    <h1>
        西工大拼车系统_内部说明
    </h1>
    <h3>
        王旻安 2023.4.11
    </h3>
</div>



## 1. Record类

record是Java14出现的一个特性(毕竟14已经这么多年了所以我们不管他叫新特性)

```java
public record EmployeeRecord(Long id, 
		String firstName, 
		String lastName, 
		String email, 
		int age) {
	
}

public class RecordExample {
	public static void main(String[] args) 
	{
		EmployeeRecord e1 = new EmployeeRecord
				(1l, "Lokesh", "Gupta", "howtodoinjava@gmail.com", 38);
		
		System.out.println(e1.id());
		System.out.println(e1.email());
		
		System.out.println(e1);
	}
}
```

需要了解更多可以访问[Record类型介绍 ](https://zhuanlan.zhihu.com/p/372678867)

我希望本次实验中的DTO部分可以多使用该特性来减少冗余代码(当然我知道lombok有时候确实显得方便得多而且灵活)



## 2. 一些内部规约

### 2.1 跨域问题

vue的proxy解决跨域问题给我一种很捉摸不定的感觉。所有跨域问题都由后端实现。



### 2.2 包名

后端各模块包名应统一命名为edu.npu



### 2.3 Json解析

我打算转jackson了。

基础的转换如下所示

```java
ObjectMapper mapper = new ObjectMapper(); 
// java对象转换为json字符换
String Json =  mapper.writeValueAsString(student1); 
// json字符串转换为java对象
Student student2 = mapper.readValue(Json, Student.class);
```

jackson-core - 基于流解析Json，就是从流中读取，生成事件，类似xml的sax。核心类是JsonGenerator和JsonParser。
jackson-annotation - 提供了注解
jackson-databind - 对jackson-core进行封装，可以实现Json和Pojo转换、Json和JsonTree(类似dom树)转换。核心类是ObjectMapper、JsonNode

配置类如下

```java
@Configuration
public class JacksonConfig {

    @Bean
    @Primary
    @ConditionalOnMissingBean(ObjectMapper.class)
    public ObjectMapper jacksonObjectMapper(Jackson2ObjectMapperBuilder builder) {
        ObjectMapper objectMapper = builder.createXmlMapper(false).build();

        // 通过该方法对mapper对象进行设置，所有序列化的对象都将按改规则进行系列化
        // Include.Include.ALWAYS 默认
        // Include.NON_DEFAULT 属性为默认值不序列化
        // Include.NON_EMPTY 属性为 空（""） 或者为 NULL 都不序列化，则返回的json是没有这个字段的。这样对移动端会更省流量
        // Include.NON_NULL 属性为NULL 不序列化
//        objectMapper.setSerializationInclusion(JsonInclude.Include.NON_EMPTY);
//        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
//        // 允许出现特殊字符和转义符
//        objectMapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_CONTROL_CHARS, true);
//        // 允许出现单引号
//        objectMapper.configure(JsonParser.Feature.ALLOW_SINGLE_QUOTES, true);

        DeserializationConfig cfg = objectMapper.getDeserializationConfig();
        //设置JSON时间格式  
        SimpleDateFormat myDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); 

        cfg.setDateFormat(myDateFormat); 
        
        objectMapper.getSerializerProvider().setNullValueSerializer(new JsonSerializer<Object>() {
            @Override
            public void serialize(Object o, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException {
                jsonGenerator.writeString("");
            }
        });
        return objectMapper;
    }

    // 配置特性属性值
    @Bean
    JacksonProperties jacksonProperties() {
        JacksonProperties properties = new JacksonProperties();
        properties.setDateFormat(DateHandler.DATETIME_PATTERN);
        properties.setJodaDateTimeFormat(DateHandler.DATETIME_PATTERN);
        properties.setTimeZone(TimeZone.getTimeZone(DateHandler.ZONEID));
        properties.getSerialization().put(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);
        return properties;
    }

    /**
     * Jackson全局转化long类型为String，解决jackson序列化时long类型缺失精度问题
     * @return Jackson2ObjectMapperBuilderCustomizer 注入的对象
     */
    @Bean
    public Jackson2ObjectMapperBuilderCustomizer jackson2ObjectMapperBuilderCustomizer() {
        Jackson2ObjectMapperBuilderCustomizer cunstomizer = new Jackson2ObjectMapperBuilderCustomizer() {
            @Override
            public void customize(Jackson2ObjectMapperBuilder jacksonObjectMapperBuilder) {
                jacksonObjectMapperBuilder.serializerByType(Long.TYPE, ToStringSerializer.instance);
                jacksonObjectMapperBuilder.serializerByType(Long.class, ToStringSerializer.instance);

            }
        };
        return cunstomizer;
    }

}
```

话说回来，咱就掰扯掰扯fastjson快不快吧！